<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>U2f (u2f.U2f)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">u2f</a> &#x00BB; U2f</nav><header class="odoc-preamble"><h1>Module <code><span>U2f</span></code></h1></header><div class="odoc-content"><p>U2F - Universal Second Factor</p><p>U2F is a standard for two-factor authentication with special USB or NFC devices. A challenge-response authentication with the device using public key cryptography is done.</p><p>This library is stateless, a client of this API has to preserve challenges (for register/authentication session), and for each registered device a quadruple of key handle, public key, certificate, and counter.</p><p>A common use of this module is that on startup a <a href="#type-t"><code>t</code></a> is created. For a registration, first <a href="#val-register_request"><code>register_request</code></a> is called (the challenge is preserved, the data is sent to the client), and <a href="#val-register_response"><code>register_response</code></a> is called with the client response (and the same challenge). If the verification succeeds, the client information (public key, key handle) is returned. To authenticate the function <a href="#val-authentication_request"><code>authentication_request</code></a> is called with the non-empty list of registered key handles. The resulting challenge is preserved, the data is sent to the client. Upon a response from the client, <a href="#val-authentication_response"><code>authentication_response</code></a> should be called with the association list of key handle and public key, the challenge, and the client response.</p><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of a u2f state, containing the version string and application ID.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create application_id</code> creates a u2f state with the provided application ID. The application ID is not validated.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-protocol_error" class="anchored"><a href="#type-protocol_error" class="anchor"></a><code><span><span class="keyword">type</span> protocol_error</span><span> = </span><span>[ </span></code><table><tr id="type-protocol_error.Other_error" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Other_error" class="anchor"></a><code><span>| </span></code><code><span>`Other_error</span></code></td></tr><tr id="type-protocol_error.Bad_request" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Bad_request" class="anchor"></a><code><span>| </span></code><code><span>`Bad_request</span></code></td></tr><tr id="type-protocol_error.Configuration_unsupported" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Configuration_unsupported" class="anchor"></a><code><span>| </span></code><code><span>`Configuration_unsupported</span></code></td></tr><tr id="type-protocol_error.Device_ineligible" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Device_ineligible" class="anchor"></a><code><span>| </span></code><code><span>`Device_ineligible</span></code></td></tr><tr id="type-protocol_error.Timeout" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Timeout" class="anchor"></a><code><span>| </span></code><code><span>`Timeout</span></code></td></tr><tr id="type-protocol_error.Unrecognized" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Unrecognized" class="anchor"></a><code><span>| </span></code><code><span>`Unrecognized <span class="keyword">of</span> int</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type of protocol errors, as specified by the standard.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_protocol_error" class="anchored"><a href="#val-pp_protocol_error" class="anchor"></a><code><span><span class="keyword">val</span> pp_protocol_error : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-protocol_error">protocol_error</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_protocol_error ppf error</code> pretty-prints the protocol <code>error</code> on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-error" class="anchored"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span><span>[ </span></code><table><tr id="type-error.Protocol" class="anchored"><td class="def constructor"><a href="#type-error.Protocol" class="anchor"></a><code><span>| </span></code><code><span>`Protocol <span class="keyword">of</span> <a href="#type-protocol_error">protocol_error</a></span></code></td></tr><tr id="type-error.Json_decoding" class="anchored"><td class="def constructor"><a href="#type-error.Json_decoding" class="anchor"></a><code><span>| </span></code><code><span>`Json_decoding <span class="keyword">of</span> string * string * string</span></code></td></tr><tr id="type-error.Base64_decoding" class="anchored"><td class="def constructor"><a href="#type-error.Base64_decoding" class="anchor"></a><code><span>| </span></code><code><span>`Base64_decoding <span class="keyword">of</span> string * string * string</span></code></td></tr><tr id="type-error.Binary_decoding" class="anchored"><td class="def constructor"><a href="#type-error.Binary_decoding" class="anchor"></a><code><span>| </span></code><code><span>`Binary_decoding <span class="keyword">of</span> string * string * string</span></code></td></tr><tr id="type-error.Version_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Version_mismatch" class="anchor"></a><code><span>| </span></code><code><span>`Version_mismatch <span class="keyword">of</span> string * string</span></code></td></tr><tr id="type-error.Typ_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Typ_mismatch" class="anchor"></a><code><span>| </span></code><code><span>`Typ_mismatch <span class="keyword">of</span> string * string</span></code></td></tr><tr id="type-error.Challenge_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Challenge_mismatch" class="anchor"></a><code><span>| </span></code><code><span>`Challenge_mismatch <span class="keyword">of</span> string * string</span></code></td></tr><tr id="type-error.Unknown_key_handle" class="anchored"><td class="def constructor"><a href="#type-error.Unknown_key_handle" class="anchor"></a><code><span>| </span></code><code><span>`Unknown_key_handle <span class="keyword">of</span> string</span></code></td></tr><tr id="type-error.Signature_verification" class="anchored"><td class="def constructor"><a href="#type-error.Signature_verification" class="anchor"></a><code><span>| </span></code><code><span>`Signature_verification <span class="keyword">of</span> string</span></code></td></tr><tr id="type-error.Origin_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Origin_mismatch" class="anchor"></a><code><span>| </span></code><code><span>`Origin_mismatch <span class="keyword">of</span> string * string</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type of errors when verifying client responses.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_error" class="anchored"><a href="#val-pp_error" class="anchor"></a><code><span><span class="keyword">val</span> pp_error : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-error">error</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_error ppf error</code> pretty-prints the <code>error</code> on <code>ppf</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-challenge" class="anchored"><a href="#type-challenge" class="anchor"></a><code><span><span class="keyword">type</span> challenge</span><span> = string</span></code></div><div class="spec-doc"><p>The type alias of a challenge.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-key_handle" class="anchored"><a href="#type-key_handle" class="anchor"></a><code><span><span class="keyword">type</span> key_handle</span><span> = string</span></code></div><div class="spec-doc"><p>The type alias of a key handle.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-register_request" class="anchored"><a href="#val-register_request" class="anchor"></a><code><span><span class="keyword">val</span> register_request : <span>?key_handles:<span><a href="#type-key_handle">key_handle</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-challenge">challenge</a> * string</span></code></div><div class="spec-doc"><p><code>register_request ~key_handles t</code> results in a challenge and data to be sent to the client. The <code>key_handles</code> should be the already registered key handles for this account. The <code>challenge</code> is randomly generated, and unique for this session. It must be passed to <a href="#val-register_response"><code>register_response</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-register_response" class="anchored"><a href="#val-register_response" class="anchor"></a><code><span><span class="keyword">val</span> register_response : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-challenge">challenge</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="xref-unresolved">Mirage_crypto_ec</span>.P256.Dsa.pub * <a href="#type-key_handle">key_handle</a> * <span class="xref-unresolved">X509</span>.Certificate.t, <a href="#type-error">error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>register_response t challenge client_data</code> verifies the <code>client_data</code> with the provided <code>challenge</code>, and data in <code>t</code> (application ID, version). On success, a tuple of public key, key handle, and certificate is returned. On error, the specific error is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-authentication_request" class="anchored"><a href="#val-authentication_request" class="anchor"></a><code><span><span class="keyword">val</span> authentication_request : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-key_handle">key_handle</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-challenge">challenge</a> * string</span></code></div><div class="spec-doc"><p><code>authentication_request t key_handles</code> randomly generates a challenge, and returns both the challenge (unique for this session, should be preserved and must be passed to <a href="#val-authentication_response"><code>authentication_response</code></a>), and the data to be sent to the client.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-authentication_response" class="anchored"><a href="#val-authentication_response" class="anchor"></a><code><span><span class="keyword">val</span> authentication_response : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-key_handle">key_handle</a> * <span class="xref-unresolved">Mirage_crypto_ec</span>.P256.Dsa.pub)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-challenge">challenge</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>(<a href="#type-key_handle">key_handle</a> * <span class="xref-unresolved">Mirage_crypto_ec</span>.P256.Dsa.pub)</span> * bool * int32, <a href="#type-error">error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>authentication_response t key_handle_pub challenge client_data</code> verifies the <code>client_data</code> using the <code>challenge</code> and looks it up in the <code>key_handle_pub</code> associative list. If successful, the used key handle and public key is returned, also a boolen whether the user was present, and the counter - an unsigned 32 bit integer. The counter should be verified to be strictly monotonically increasing for the key handle and public key.</p></div></div></div></body></html>